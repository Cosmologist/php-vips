{
  "name": "php-vips",
  "tagline": "php binding for libvips",
  "body": "# High-level PHP binding for libvips \r\n\r\n`php-vips` is a binding for [libvips](https://github.com/jcupitt/libvips) for\r\nPHP 7. We have a set of [formatted API docs](docs/index.html). \r\n\r\nlibvips is fast and needs little memory. The [`vips-php-bench`](\r\nhttps://github.com/jcupitt/php-vips-bench) repository tests\r\n`php-vips` against `imagick` and `gd`. On that test, and on my laptop,\r\n`php-vips` is around four times faster than `imagick` and needs 10 times less\r\nmemory. \r\n\r\nPrograms that use libvips don't manipulate images directly, instead they\r\ncreate pipelines of image processing operations starting from a source\r\nimage. When the pipe is connected to a destination, the whole pipeline\r\nexecutes at once and in parallel, streaming the image from source to\r\ndestination in a set of small fragments.\r\n\r\nThis module builds upon the `vips` PHP extension, see:\r\n\r\nhttps://github.com/jcupitt/php-vips-ext\r\n\r\nYou'll need to install that first. It's tested on Linux and macOS --- \r\nWindows would need some work, but should be possible.  \r\n\r\n### Example\r\n\r\n```php\r\n#!/usr/bin/env php\r\n<?php\r\nrequire __DIR__ . '/vendor/autoload.php';\r\nuse Jcupitt\\Vips;\r\n\r\n$image = Vips\\Image::newFromFile($argv[1]);\r\n\r\necho \"width = \", $image->width, \"\\n\";\r\n\r\n$image = $image->invert();\r\n\r\n$image->writeToFile($argv[2]);\r\n?>\r\n```\r\n\r\nYou'll need this in your `composer.json`:\r\n\r\n```\r\n    \"require\": {\r\n            \"jcupitt/vips\" : \"1.0.0\"\r\n    }\r\n```\r\n\r\nAnd run with:\r\n\r\n```\r\n$ composer install\r\n$ ./try1.php ~/pics/k2.jpg x.tif\r\n```\r\n\r\nSee `examples/`.\r\n\r\n### Introduction to the API\r\n\r\nAlmost all methods return a new image for the result, so you can chain them.\r\nFor example:\r\n\r\n```php\r\n$image = $image->more(12)->ifthenelse(255, $image);\r\n```\r\n\r\nwill make a mask of pixels greater than 12, then use the mask to set pixels to\r\neither 255 or the original image.\r\n\r\nYou use long, double, array and image as parameters. For example:\r\n\r\n```php\r\n$image = $image->add(2);\r\n```\r\n\r\nto add two to every band element, or:\r\n\r\n```php\r\n$image = $image->add([1, 2, 3]);\r\n```\r\n\r\nto add 1 to the first band, 2 to the second and 3 to the third. Or:\r\n\r\n```php\r\n$image = $image->add($image2);\r\n```\r\n\r\nto add two images. Or: \r\n\r\n```php\r\n$image = $image->add([[1, 2, 3], [4, 5, 6]]);\r\n```\r\n\r\nTo make a 2 x 3 image from the array, then add that image to the original.\r\n\r\nAlmost all methods can take an extra final argument: an array of options.\r\nFor example:\r\n\r\n```php\r\n$image->writeToFile(\"fred.jpg\", [\"Q\" => 90]);\r\n```\r\n\r\n`php-vips` comes with full API docs, run:\r\n\r\n```\r\n$ vendor/bin/phpdoc\r\n```\r\n\r\nAnd look in `docs/`.\r\n\r\nThere are around 300 operations in the library, see the vips docs for an\r\nintroduction:\r\n\r\nhttp://www.vips.ecs.soton.ac.uk/supported/current/doc/html/libvips/\r\n\r\n### How it works\r\n\r\nThe `vips` extension defines a simple but ugly way to call any libvips\r\noperation from PHP.  It uses libvips' own introspection facilities\r\nand does not depend on anything else (so no gobject-introspection,\r\nfor example). It's a fairly short 1,600 lines of C.\r\n\r\nThis module is a PHP layer over the ugly `vips` extension that\r\ntries to make a nice interface for programmers. It uses `__call()` and\r\n`__get()` to make all libvips operations appear as methods, and all\r\nlibvips properties as properties of the PHP `Vips\\Image` class.\r\n\r\n### Test and install\r\n\r\n```\r\n$ phpcs --standard=PSR2 src\r\n$ php ~/packages/php/composer.phar install\r\n$ vendor/bin/phpunit\r\n$ vendor/bin/phpdoc\r\n```\r\n\r\n### Regenerate auto docs\r\n\r\n```\r\n$ cd src\r\n$ ../examples/generate_phpdoc.rb\r\n```\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}